"""
Literate Example: Spelling Correction (Python, dictionary-driven)

This example demonstrates ranked programming for spelling correction using ranked choices and a real dictionary.

- The goal is to correct the word 'hte' (intended: 'the').
- All possible corrections are generated by edit operations (insert, delete, substitute, wildcard).
- Only candidates in the dictionary are kept.
- The output is a ranking of possible corrections, ranked by number of edits (plausibility).

Run this file to see the ranked output for the spelling correction scenario.
"""
from ranked_programming.rp_core import Ranking, nrm_exc, pr_all
import os

# Load dictionary from file (as set of tuples of chars)
dict_path = os.path.join(os.path.dirname(__file__), '..', 'google-10000-english-no-swears.txt')
with open(dict_path, 'r') as f:
    DICTIONARY = set(tuple(line.strip()) for line in f if line.strip())

def edits(word, max_edits=3, current_edits=0, seen=None):
    """Recursively generate all possible edits (insert, delete, substitute, wildcard) for the word as tuples of chars, up to max_edits."""
    if seen is None:
        seen = set()
    word = tuple(word)
    if (word, current_edits) in seen or current_edits > max_edits:
        return
    seen.add((word, current_edits))
    yield (word, current_edits)
    n = len(word)
    # Deletion
    for i in range(n):
        w = word[:i] + word[i+1:]
        yield from edits(w, max_edits, current_edits + 1, seen)
    # Insertion (wildcard)
    for i in range(n+1):
        w = word[:i] + ('*',) + word[i:]
        yield from edits(w, max_edits, current_edits + 1, seen)
    # Substitution (wildcard)
    for i in range(n):
        w = word[:i] + ('*',) + word[i+1:]
        yield from edits(w, max_edits, current_edits + 1, seen)
    # Transposition (swap adjacent characters)
    for i in range(n-1):
        w = word[:i] + (word[i+1], word[i]) + word[i+2:]
        yield from edits(w, max_edits, current_edits + 1, seen)


def matches_pattern(pattern, dictionary):
    """Return all words in the dictionary that match the pattern (with '*' as wildcard)."""
    plen = len(pattern)
    results = set()
    for word in dictionary:
        if len(word) != plen:
            continue
        for c1, c2 in zip(pattern, word):
            if c1 != '*' and c1 != c2:
                break
        else:
            results.add(word)
    return results


def spelling_correction_example():
    input_word = 'hte'
    # Generate all edits up to 3 edits
    candidates = dict()  # word -> min edits
    for pattern, edits_count in edits(input_word, max_edits=3):
        for match in matches_pattern(pattern, DICTIONARY):
            if match not in candidates or edits_count < candidates[match]:
                candidates[match] = edits_count
    # Print ranked candidates
    print(f"Spelling correction output ranking for '{input_word}':")
    print("Rank  Value\n------------")
    for w, rank in sorted(candidates.items(), key=lambda x: (x[1], x[0]))[:10]:
        print(f"{rank:<5} {''.join(w)}")
    print("...")

if __name__ == "__main__":
    spelling_correction_example()
